-- ============================================================
-- Comprehensive Database Fix Migration
-- Fixes: operations tables creation with correct TEXT organization_id
-- Note: IDs are generated by the application (cuid/UUID strings)
-- ============================================================

-- Create uuid extension if not exists (for generating UUIDs in seed data)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================================
-- DROP AND RECREATE OPERATIONS TABLES WITH CORRECT TYPES
-- ============================================================

-- Drop existing tables if they exist (with CASCADE to handle dependencies)
DROP TABLE IF EXISTS public.hole_patterns CASCADE;
DROP TABLE IF EXISTS public.groove_profiles CASCADE;
DROP TABLE IF EXISTS public.routing_profiles CASCADE;

-- ============================================================
-- HOLE PATTERNS TABLE (with TEXT organization_id)
-- ============================================================

CREATE TABLE public.hole_patterns (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
  organization_id TEXT NOT NULL,
  
  pattern_id VARCHAR(50) NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  
  kind VARCHAR(50) NOT NULL,
  holes JSONB NOT NULL DEFAULT '[]'::jsonb,
  
  ref_edge VARCHAR(10),
  ref_corner VARCHAR(20),
  parametric_config JSONB,
  
  hardware_id VARCHAR(100),
  hardware_brand VARCHAR(100),
  hardware_model VARCHAR(100),
  
  is_system BOOLEAN DEFAULT FALSE,
  is_active BOOLEAN DEFAULT TRUE,
  usage_count INT DEFAULT 0,
  
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  CONSTRAINT hole_patterns_org_pattern_unique UNIQUE(organization_id, pattern_id)
);

-- Indexes for hole_patterns
CREATE INDEX idx_hole_patterns_org ON public.hole_patterns(organization_id);
CREATE INDEX idx_hole_patterns_kind ON public.hole_patterns(kind);
CREATE INDEX idx_hole_patterns_active ON public.hole_patterns(is_active) WHERE is_active = true;

-- ============================================================
-- GROOVE PROFILES TABLE (with TEXT organization_id)
-- ============================================================

CREATE TABLE public.groove_profiles (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
  organization_id TEXT NOT NULL,
  
  profile_id VARCHAR(50) NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  
  width_mm DECIMAL(6,2) NOT NULL,
  depth_mm DECIMAL(6,2) NOT NULL,
  
  purpose VARCHAR(50),
  default_offset_mm DECIMAL(6,2) DEFAULT 10,
  default_face VARCHAR(10) DEFAULT 'back',
  
  allow_stopped BOOLEAN DEFAULT TRUE,
  default_start_offset_mm DECIMAL(6,2) DEFAULT 0,
  default_end_offset_mm DECIMAL(6,2) DEFAULT 0,
  
  tool_dia_mm DECIMAL(6,2),
  tool_id VARCHAR(100),
  feed_rate INT,
  
  is_system BOOLEAN DEFAULT FALSE,
  is_active BOOLEAN DEFAULT TRUE,
  usage_count INT DEFAULT 0,
  
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  CONSTRAINT groove_profiles_org_profile_unique UNIQUE(organization_id, profile_id)
);

-- Indexes for groove_profiles
CREATE INDEX idx_groove_profiles_org ON public.groove_profiles(organization_id);
CREATE INDEX idx_groove_profiles_purpose ON public.groove_profiles(purpose);
CREATE INDEX idx_groove_profiles_active ON public.groove_profiles(is_active) WHERE is_active = true;

-- ============================================================
-- ROUTING PROFILES TABLE (with TEXT organization_id)
-- ============================================================

CREATE TABLE public.routing_profiles (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
  organization_id TEXT NOT NULL,
  
  profile_id VARCHAR(50) NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  
  profile_type VARCHAR(50) NOT NULL,
  specifications JSONB NOT NULL DEFAULT '{}'::jsonb,
  
  tool_dia_mm DECIMAL(6,2),
  tool_id VARCHAR(100),
  tool_type VARCHAR(50),
  feed_rate INT,
  plunge_rate INT,
  spindle_speed INT,
  step_down_mm DECIMAL(6,2),
  
  dxf_layer VARCHAR(100),
  gcode_template TEXT,
  
  is_system BOOLEAN DEFAULT FALSE,
  is_active BOOLEAN DEFAULT TRUE,
  usage_count INT DEFAULT 0,
  
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  CONSTRAINT routing_profiles_org_profile_unique UNIQUE(organization_id, profile_id)
);

-- Indexes for routing_profiles
CREATE INDEX idx_routing_profiles_org ON public.routing_profiles(organization_id);
CREATE INDEX idx_routing_profiles_type ON public.routing_profiles(profile_type);
CREATE INDEX idx_routing_profiles_active ON public.routing_profiles(is_active) WHERE is_active = true;

-- ============================================================
-- ENABLE ROW LEVEL SECURITY
-- ============================================================

ALTER TABLE public.hole_patterns ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.groove_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.routing_profiles ENABLE ROW LEVEL SECURITY;

-- ============================================================
-- RLS POLICIES FOR HOLE PATTERNS
-- ============================================================

CREATE POLICY "Users can view their organization's hole patterns" ON public.hole_patterns
  FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM public.users WHERE id = auth.uid()::text
    )
  );

CREATE POLICY "Org admins can manage hole patterns" ON public.hole_patterns
  FOR ALL
  USING (
    organization_id IN (
      SELECT u.organization_id FROM public.users u
      LEFT JOIN public.roles r ON u.role_id = r.id
      WHERE u.id = auth.uid()::text 
        AND (u.is_super_admin = true OR r.name IN ('org_admin', 'manager'))
    )
  );

-- ============================================================
-- RLS POLICIES FOR GROOVE PROFILES
-- ============================================================

CREATE POLICY "Users can view their organization's groove profiles" ON public.groove_profiles
  FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM public.users WHERE id = auth.uid()::text
    )
  );

CREATE POLICY "Org admins can manage groove profiles" ON public.groove_profiles
  FOR ALL
  USING (
    organization_id IN (
      SELECT u.organization_id FROM public.users u
      LEFT JOIN public.roles r ON u.role_id = r.id
      WHERE u.id = auth.uid()::text 
        AND (u.is_super_admin = true OR r.name IN ('org_admin', 'manager'))
    )
  );

-- ============================================================
-- RLS POLICIES FOR ROUTING PROFILES
-- ============================================================

CREATE POLICY "Users can view their organization's routing profiles" ON public.routing_profiles
  FOR SELECT
  USING (
    organization_id IN (
      SELECT organization_id FROM public.users WHERE id = auth.uid()::text
    )
  );

CREATE POLICY "Org admins can manage routing profiles" ON public.routing_profiles
  FOR ALL
  USING (
    organization_id IN (
      SELECT u.organization_id FROM public.users u
      LEFT JOIN public.roles r ON u.role_id = r.id
      WHERE u.id = auth.uid()::text 
        AND (u.is_super_admin = true OR r.name IN ('org_admin', 'manager'))
    )
  );

-- ============================================================
-- TRIGGERS FOR UPDATED_AT
-- ============================================================

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_hole_patterns_updated_at ON public.hole_patterns;
CREATE TRIGGER update_hole_patterns_updated_at
  BEFORE UPDATE ON public.hole_patterns
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_groove_profiles_updated_at ON public.groove_profiles;
CREATE TRIGGER update_groove_profiles_updated_at
  BEFORE UPDATE ON public.groove_profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_routing_profiles_updated_at ON public.routing_profiles;
CREATE TRIGGER update_routing_profiles_updated_at
  BEFORE UPDATE ON public.routing_profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ============================================================
-- SEED DEFAULT DATA FOR ALL EXISTING ORGANIZATIONS
-- ============================================================

-- Seed default hole patterns
INSERT INTO public.hole_patterns (organization_id, pattern_id, name, kind, holes, is_system, description)
SELECT 
  o.id,
  patterns.pattern_id,
  patterns.name,
  patterns.kind,
  patterns.holes::jsonb,
  true,
  patterns.description
FROM public.organizations o
CROSS JOIN (
  VALUES 
    ('HINGE_35', 'Hinge 35mm Cup', 'hinge', '[{"x":0,"y":0,"dia_mm":35,"depth_mm":13}]', 'Standard 35mm European hinge cup'),
    ('HINGE_26', 'Hinge 26mm Cup', 'hinge', '[{"x":0,"y":0,"dia_mm":26,"depth_mm":13}]', 'Compact 26mm hinge cup'),
    ('SYS32_5H', 'System 32 - 5 Holes', 'shelf_pins', '[{"x":37,"y":0,"dia_mm":5,"depth_mm":13},{"x":37,"y":32,"dia_mm":5,"depth_mm":13},{"x":37,"y":64,"dia_mm":5,"depth_mm":13},{"x":37,"y":96,"dia_mm":5,"depth_mm":13},{"x":37,"y":128,"dia_mm":5,"depth_mm":13}]', 'System 32 vertical row of 5 shelf pin holes'),
    ('CAM_LOCK', 'Cam Lock Pair', 'cam_lock', '[{"x":0,"y":0,"dia_mm":15,"depth_mm":12.5},{"x":34,"y":0,"dia_mm":8,"depth_mm":35,"through":true}]', 'Cam lock fitting hole pair'),
    ('HANDLE_CC96', 'Handle CC96', 'handle', '[{"x":0,"y":0,"dia_mm":5,"depth_mm":25},{"x":96,"y":0,"dia_mm":5,"depth_mm":25}]', 'Handle holes at 96mm centers'),
    ('HANDLE_CC128', 'Handle CC128', 'handle', '[{"x":0,"y":0,"dia_mm":5,"depth_mm":25},{"x":128,"y":0,"dia_mm":5,"depth_mm":25}]', 'Handle holes at 128mm centers')
) AS patterns(pattern_id, name, kind, holes, description)
ON CONFLICT (organization_id, pattern_id) DO NOTHING;

-- Seed default groove profiles
INSERT INTO public.groove_profiles (organization_id, profile_id, name, width_mm, depth_mm, purpose, is_system, description)
SELECT 
  o.id,
  profiles.profile_id,
  profiles.name,
  profiles.width_mm,
  profiles.depth_mm,
  profiles.purpose,
  true,
  profiles.description
FROM public.organizations o
CROSS JOIN (
  VALUES 
    ('BP_4x10', 'Back Panel 4x10', 4.0, 10.0, 'back_panel', 'Standard groove for 4mm back panels'),
    ('BP_6x10', 'Back Panel 6x10', 6.0, 10.0, 'back_panel', 'Groove for 6mm back panels'),
    ('DB_6x10', 'Drawer Bottom 6x10', 6.0, 10.0, 'drawer_bottom', 'Standard groove for drawer bottoms'),
    ('DADO_18', 'Dado for 18mm', 18.0, 10.0, 'divider', 'Dado for 18mm dividers/shelves'),
    ('TONGUE_6x8', 'Tongue 6x8', 6.0, 8.0, 'custom', 'Tongue for T&G joints')
) AS profiles(profile_id, name, width_mm, depth_mm, purpose, description)
ON CONFLICT (organization_id, profile_id) DO NOTHING;

-- Seed default routing profiles
INSERT INTO public.routing_profiles (organization_id, profile_id, name, profile_type, specifications, is_system, description)
SELECT 
  o.id,
  profiles.profile_id,
  profiles.name,
  profiles.profile_type,
  profiles.specifications::jsonb,
  true,
  profiles.description
FROM public.organizations o
CROSS JOIN (
  VALUES 
    ('EDGE_ROUND_3', 'Edge Round 3mm', 'edge_profile', '{"shape":"round","radius_mm":3}', '3mm radius edge profile'),
    ('EDGE_CHAMFER_2x45', 'Chamfer 2x45Â°', 'chamfer', '{"width_mm":2,"angle_deg":45}', '2mm 45 degree chamfer'),
    ('SINK_CUTOUT', 'Sink Cutout', 'cutout', '{"shape":"rect","purpose":"sink","corner_radius_mm":25}', 'Rectangular sink cutout with rounded corners'),
    ('POCKET_STD', 'Standard Pocket', 'pocket', '{"default_depth_mm":10,"through_allowed":false}', 'Standard pocket routing'),
    ('CORNER_RAD_10', 'Corner Radius 10mm', 'radius', '{"radius_mm":10,"corners":"all"}', '10mm radius on all corners')
) AS profiles(profile_id, name, profile_type, specifications, description)
ON CONFLICT (organization_id, profile_id) DO NOTHING;

-- ============================================================
-- ENSURE GROOVE_TYPES TABLE EXISTS WITH CORRECT SCHEMA
-- ============================================================

CREATE TABLE IF NOT EXISTS public.groove_types (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
  organization_id TEXT NOT NULL,
  
  code VARCHAR(20) NOT NULL,
  name VARCHAR(100) NOT NULL,
  default_width_mm DECIMAL(6,2),
  default_depth_mm DECIMAL(6,2),
  description TEXT,
  is_active BOOLEAN DEFAULT true NOT NULL,
  
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  CONSTRAINT groove_types_org_code_unique UNIQUE(organization_id, code)
);

CREATE INDEX IF NOT EXISTS idx_groove_types_org ON public.groove_types(organization_id);
ALTER TABLE public.groove_types ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their organization's groove types" ON public.groove_types;
DROP POLICY IF EXISTS "Org admins can manage groove types" ON public.groove_types;

CREATE POLICY "Users can view their organization's groove types" ON public.groove_types
  FOR SELECT USING (organization_id IN (SELECT organization_id FROM public.users WHERE id = auth.uid()::text));

CREATE POLICY "Org admins can manage groove types" ON public.groove_types
  FOR ALL USING (organization_id IN (
    SELECT u.organization_id FROM public.users u
    LEFT JOIN public.roles r ON u.role_id = r.id
    WHERE u.id = auth.uid()::text AND (u.is_super_admin = true OR r.name IN ('org_admin', 'manager'))
  ));

-- ============================================================
-- ENSURE HOLE_TYPES TABLE EXISTS WITH CORRECT SCHEMA
-- ============================================================

CREATE TABLE IF NOT EXISTS public.hole_types (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
  organization_id TEXT NOT NULL,
  
  code VARCHAR(20) NOT NULL,
  name VARCHAR(100) NOT NULL,
  diameter_mm DECIMAL(6,2),
  depth_mm DECIMAL(6,2),
  spacing_mm DECIMAL(6,2),
  pattern_id VARCHAR(50),
  description TEXT,
  is_active BOOLEAN DEFAULT true NOT NULL,
  
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  CONSTRAINT hole_types_org_code_unique UNIQUE(organization_id, code)
);

CREATE INDEX IF NOT EXISTS idx_hole_types_org ON public.hole_types(organization_id);
ALTER TABLE public.hole_types ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their organization's hole types" ON public.hole_types;
DROP POLICY IF EXISTS "Org admins can manage hole types" ON public.hole_types;

CREATE POLICY "Users can view their organization's hole types" ON public.hole_types
  FOR SELECT USING (organization_id IN (SELECT organization_id FROM public.users WHERE id = auth.uid()::text));

CREATE POLICY "Org admins can manage hole types" ON public.hole_types
  FOR ALL USING (organization_id IN (
    SELECT u.organization_id FROM public.users u
    LEFT JOIN public.roles r ON u.role_id = r.id
    WHERE u.id = auth.uid()::text AND (u.is_super_admin = true OR r.name IN ('org_admin', 'manager'))
  ));

-- ============================================================
-- ENSURE CNC_OPERATION_TYPES TABLE EXISTS WITH CORRECT SCHEMA
-- ============================================================

CREATE TABLE IF NOT EXISTS public.cnc_operation_types (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
  organization_id TEXT NOT NULL,
  
  code VARCHAR(20) NOT NULL,
  name VARCHAR(100) NOT NULL,
  op_type VARCHAR(50),
  default_params JSONB DEFAULT '{}'::jsonb,
  profile_id VARCHAR(50),
  description TEXT,
  is_active BOOLEAN DEFAULT true NOT NULL,
  
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  CONSTRAINT cnc_operation_types_org_code_unique UNIQUE(organization_id, code)
);

CREATE INDEX IF NOT EXISTS idx_cnc_operation_types_org ON public.cnc_operation_types(organization_id);
ALTER TABLE public.cnc_operation_types ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their organization's cnc operation types" ON public.cnc_operation_types;
DROP POLICY IF EXISTS "Org admins can manage cnc operation types" ON public.cnc_operation_types;

CREATE POLICY "Users can view their organization's cnc operation types" ON public.cnc_operation_types
  FOR SELECT USING (organization_id IN (SELECT organization_id FROM public.users WHERE id = auth.uid()::text));

CREATE POLICY "Org admins can manage cnc operation types" ON public.cnc_operation_types
  FOR ALL USING (organization_id IN (
    SELECT u.organization_id FROM public.users u
    LEFT JOIN public.roles r ON u.role_id = r.id
    WHERE u.id = auth.uid()::text AND (u.is_super_admin = true OR r.name IN ('org_admin', 'manager'))
  ));

-- ============================================================
-- ENSURE SHORTCODE_CONFIGS TABLE EXISTS WITH CORRECT SCHEMA
-- ============================================================

CREATE TABLE IF NOT EXISTS public.shortcode_configs (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
  organization_id TEXT NOT NULL,
  user_id TEXT,
  
  operation_type VARCHAR(50) NOT NULL,
  format VARCHAR(20) DEFAULT 'compact',
  show_types BOOLEAN DEFAULT true,
  show_specs BOOLEAN DEFAULT false,
  custom_template TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  CONSTRAINT shortcode_configs_unique UNIQUE(organization_id, user_id, operation_type)
);

CREATE INDEX IF NOT EXISTS idx_shortcode_configs_org ON public.shortcode_configs(organization_id);
ALTER TABLE public.shortcode_configs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their organization's shortcode configs" ON public.shortcode_configs;
DROP POLICY IF EXISTS "Org admins can manage shortcode configs" ON public.shortcode_configs;

CREATE POLICY "Users can view their organization's shortcode configs" ON public.shortcode_configs
  FOR SELECT USING (organization_id IN (SELECT organization_id FROM public.users WHERE id = auth.uid()::text));

CREATE POLICY "Org admins can manage shortcode configs" ON public.shortcode_configs
  FOR ALL USING (organization_id IN (
    SELECT u.organization_id FROM public.users u
    LEFT JOIN public.roles r ON u.role_id = r.id
    WHERE u.id = auth.uid()::text AND (u.is_super_admin = true OR r.name IN ('org_admin', 'manager'))
  ));

-- ============================================================
-- REFRESH SUPABASE SCHEMA CACHE
-- ============================================================

-- Notify Supabase to refresh its schema cache
NOTIFY pgrst, 'reload schema';

-- ============================================================
-- COMMENTS
-- ============================================================

COMMENT ON TABLE public.hole_patterns IS 'Per-organization library of reusable drilling patterns';
COMMENT ON TABLE public.groove_profiles IS 'Per-organization library of groove specifications';
COMMENT ON TABLE public.routing_profiles IS 'Per-organization library of CNC routing operations';
COMMENT ON TABLE public.groove_types IS 'Organization-defined groove type shortcodes';
COMMENT ON TABLE public.hole_types IS 'Organization-defined hole type shortcodes';
COMMENT ON TABLE public.cnc_operation_types IS 'Organization-defined CNC operation shortcodes';
COMMENT ON TABLE public.shortcode_configs IS 'User/org shortcode display configurations';

